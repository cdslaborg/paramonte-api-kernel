\hypertarget{interfaceArrayComparison__mod_1_1iseqall}{}\doxysection{Array\+Comparison\+\_\+mod\+::iseqall Interface Reference}
\label{interfaceArrayComparison__mod_1_1iseqall}\index{ArrayComparison\_mod::iseqall@{ArrayComparison\_mod::iseqall}}


Generate and return {\ttfamily .true.} if all elements of two input objects are equal in value, otherwise, return {\ttfamily .false.}.  




\doxysubsection{Detailed Description}
Generate and return {\ttfamily .true.} if all elements of two input objects are equal in value, otherwise, return {\ttfamily .false.}. 


\begin{DoxyParams}[1]{Parameters}
\mbox{\texttt{ in,out}}  & {\em Value1} & \+: The input scalar or contiguous array shape {\ttfamily (\+:)} of either ~\newline
 ~ type {\ttfamily integer} of kind \mbox{\hyperlink{namespaceConstants__mod_ae3573d46486b5f1a0a8d5033a9d12879}{IK8}}, \mbox{\hyperlink{namespaceConstants__mod_acd3c33e94d12f6e7d7c0ee79b2d6280b}{IK16}}, \mbox{\hyperlink{namespaceConstants__mod_ab12a86d74008f0d7f287c3564c3defd9}{IK32}}, or \mbox{\hyperlink{namespaceConstants__mod_ad6aaf2f477491dc84e7ebbab3b64694e}{IK64}}, or ~\newline
 ~ type {\ttfamily complex} of kind \mbox{\hyperlink{namespaceConstants__mod_ac8b456bd9511bc9a52b4a03bda4b72df}{CK32}}, \mbox{\hyperlink{namespaceConstants__mod_aa6ea61256fca0b20db0ec2b90755b9f3}{CK64}}, or \mbox{\hyperlink{namespaceConstants__mod_ad3873e1ecc5eb3cf3651f72630cae087}{CK128}}, or ~\newline
 ~ type {\ttfamily real} of kind \mbox{\hyperlink{namespaceConstants__mod_aaf5c6c840ed0befe5a37da626c35716f}{RK32}}, \mbox{\hyperlink{namespaceConstants__mod_a855643f887b4c787e6542e9e7849680f}{RK64}}, or \mbox{\hyperlink{namespaceConstants__mod_aeef7c44b90b75aeeebdef1da504886cb}{RK128}}, or ~\newline
 ~ type {\ttfamily logical} of default kind \mbox{\hyperlink{namespaceConstants__mod_a68ac316f10b57be996670bc7c0abed9d}{LK}}, or ~\newline
 ~ type {\ttfamily character} of default kind, or ~\newline
 ~ a scalar assumed-\/length {\ttfamily character} of default kind, ~\newline
 ~ whose elements will be compared with the input scalar {\ttfamily Value1} or ~\newline
 ~ with the corresponding values in the input array {\ttfamily Value1}. ~\newline
 The the {\ttfamily allocatable} attribute and the reallocation of {\ttfamily Array} is essential for efficient fast reordering of {\ttfamily Array}. \\
\hline
\mbox{\texttt{ in}}  & {\em Index} & \+: The input contiguous array of shape {\ttfamily (\+:)} of type {\ttfamily integer} of default kind \mbox{\hyperlink{namespaceConstants__mod_a2bf4d6767c9954d3a495d10ab6b538d6}{IK}} of the same size as {\ttfamily Array}, containing the reordering indices. \\
\hline
\mbox{\texttt{ in}}  & {\em backward} & \+: The input logical of default kind \mbox{\hyperlink{namespaceConstants__mod_a68ac316f10b57be996670bc7c0abed9d}{LK}}. If {\ttfamily .true.}, then {\ttfamily Array} will be reordered to {\ttfamily Array(Index(size(\+Index)\+:1\+:-\/1))}, otherwise, {\ttfamily Array} will be reordered to {\ttfamily Array(\+Index)} ({\bfseries{optional}}, default = {\ttfamily .false.}). \\
\hline
\mbox{\texttt{ out}}  & {\em Array\+New} & \+: The output contiguous array of the same type, kind, shape, and size as the input {\ttfamily Array} that will contain the reordered array ({\bfseries{optional}}, if missing, the ordered array will stored and output in the input allocatable {\ttfamily Array} {\bfseries{in-\/place}}).\\
\hline
\end{DoxyParams}
\label{interfaceArraySplit__mod_1_1split_interface}%
\Hypertarget{interfaceArraySplit__mod_1_1split_interface}%
{\bfseries{Possible calling interfaces}} \href{\#interface}{\texttt{ ⛓}} \begin{DoxyParagraph}{}

\begin{DoxyCode}{0}
\DoxyCodeLine{\textcolor{fortran_statement}{use }ArrayAll\_mod, \textcolor{fortran_statement}{only}: remap}
\DoxyCodeLine{}
\DoxyCodeLine{\textcolor{fortran_statement}{call} remap(Array, Index)}
\DoxyCodeLine{\textcolor{fortran_statement}{call} remap(Array, Index, backward)}
\DoxyCodeLine{\textcolor{fortran_statement}{call} remap(Array, Index, ArrayNew\textcolor{fortran_operator_symbols}{ = }ArrayNew)}
\DoxyCodeLine{\textcolor{fortran_statement}{call} remap(Array, Index, backward, ArrayNew)}

\end{DoxyCode}

\end{DoxyParagraph}
\begin{DoxyWarning}{Warning}
This {\ttfamily pure} procedures documented herein become {\ttfamily impure} when the Para\+Monte library is compiled with preprocessor macro {\ttfamily CHECK\+\_\+\+ENABLED=1}. By default, {\ttfamily pure} procedures are {\ttfamily pure} in {\ttfamily release} build and {\ttfamily impure} in {\ttfamily debug} and {\ttfamily testing} builds.

The sizes of {\ttfamily Array}, {\ttfamily Array\+New}, and {\ttfamily Index} arguments must be equal. This condition is checked only when the preprocessor macro {\ttfamily CHECK\+\_\+\+ENABLED=1} is set at library build time.
\end{DoxyWarning}
\begin{DoxyRemark}{Remarks}
The primary purpose of the procedures under this generic interface is to provide a more efficient faster method of remapping an array of any intrinsic type and kind, in place, without an extra copy that is implicitly done by current compilers with the regular Fortran syntax. This generic interface also provides a comfortable generic way to reverse arrays of any intrinsic type and kind. This is particularly useful in case of scalar character. With further compiler and language template enhancements in the future, the need for the procedures under this generic interface might be resolved in the future. See Array\+All\+\_\+mod for the relevant benchmarks.
\end{DoxyRemark}
\begin{DoxySeeAlso}{See also}
\mbox{\hyperlink{interfaceArrayShuffle__mod_1_1shuffle}{shuffle}} ~\newline
 \mbox{\hyperlink{interfaceArrayReverse__mod_1_1genReverse}{gen\+Reverse}} ~\newline
 get\+Reverse ~\newline

\end{DoxySeeAlso}
\label{namespaceInterpLinear__mod_example}%
\Hypertarget{namespaceInterpLinear__mod_example}%
{\bfseries{Example usage}} \href{\#example}{\texttt{ ⛓}} \begin{DoxyParagraph}{}

\begin{DoxyCodeInclude}{0}

\end{DoxyCodeInclude}
 ~\newline
 \label{namespaceBench__mod_compile-unix-gnu}%
\Hypertarget{namespaceBench__mod_compile-unix-gnu}%
{\bfseries{Example Unix compile command via GNU {\ttfamily gfortran} compiler}} \href{\#compile-unix-gnu}{\texttt{ ⛓}} 
\begin{DoxyCodeInclude}{0}
\DoxyCodeLine{\Hypertarget{interfaceArrayComparison__mod_1_1iseqall_l00001}00001 \#!/bin/bash}
\DoxyCodeLine{\Hypertarget{interfaceArrayComparison__mod_1_1iseqall_l00002}00002 gfortran -\/O3 -\/ffree-\/line-\/length-\/none -\/Wl,-\/rpath,../../../../lib -\/I../../../../include main.f90 ../../../../lib/libparamonte\_fortran\_*\_gnu\_*.so -\/o main.exe}
\DoxyCodeLine{\Hypertarget{interfaceArrayComparison__mod_1_1iseqall_l00003}00003 ./main.exe}

\end{DoxyCodeInclude}
 ~\newline
 \label{namespaceBench__mod_compile-unix-intel}%
\Hypertarget{namespaceBench__mod_compile-unix-intel}%
{\bfseries{Example Unix compile command via Intel {\ttfamily ifort} compiler}} \href{\#compile-unix-intel}{\texttt{ ⛓}} 
\begin{DoxyCodeInclude}{0}
\DoxyCodeLine{\Hypertarget{interfaceArrayComparison__mod_1_1iseqall_l00001}00001 \#!/bin/bash}
\DoxyCodeLine{\Hypertarget{interfaceArrayComparison__mod_1_1iseqall_l00002}00002 ifort -\/standard-\/semantics -\/O3 -\/Wl,-\/rpath,../../../../lib -\/I../../../../include main.f90 ../../../../lib/libparamonte\_fortran\_*\_intel\_*.so -\/o main.exe}
\DoxyCodeLine{\Hypertarget{interfaceArrayComparison__mod_1_1iseqall_l00003}00003 ./main.exe}

\end{DoxyCodeInclude}
 ~\newline
 \label{namespaceBench__mod_output}%
\Hypertarget{namespaceBench__mod_output}%
{\bfseries{Example output}} \href{\#output}{\texttt{ ⛓}} 
\begin{DoxyCodeInclude}{0}

\end{DoxyCodeInclude}

\end{DoxyParagraph}
\begin{DoxyRefDesc}{Test}
\item[\mbox{\hyperlink{test__test000001}{Test}}]Test\+\_\+\+Array\+All\+\_\+mod\end{DoxyRefDesc}


\begin{DoxyRefDesc}{Bug}
\item[\mbox{\hyperlink{bug__bug000001}{Bug}}]There is still a bug in gfortran as of version 10.\+3, where the compiler fails to properly deallocate the array of origin in a call to intrinsic {\ttfamily move\+\_\+alloc}\+: \end{DoxyRefDesc}

\begin{DoxyCode}{0}
\DoxyCodeLine{\textcolor{fortran_comment}{call move\_alloc(from = ArrayNew, to = Array)}}

\end{DoxyCode}
 Currently, a preprocessor fence is added specifically for gfortran to explicitly deallocate {\ttfamily Array\+New} after the call to {\ttfamily move\+\_\+alloc()}. This is going to yield an extra tiny performance penalty. Upon the necessary corrections to gfortran, this extra preprocessing fence must be removed.

\begin{DoxyRefDesc}{Bug}
\item[\mbox{\hyperlink{bug__bug000002}{Bug}}]gfortran currently does not accept deferred-\/length allocatable characters as actual argument to procedures with assumed-\/length allocatable dummy arguments.\end{DoxyRefDesc}


\begin{DoxyRefDesc}{Todo}
\item[\mbox{\hyperlink{todo__todo000001}{Todo}}]This generic interface can be extended to 2D input objects. ~\newline
 The gfortran bugs in the implementations of this generic interface must be resolved in the future. ~\newline
\end{DoxyRefDesc}


\begin{DoxyRemark}{Remarks}
For details of naming abbreviations, see \mbox{\hyperlink{index_ParaMonteAbbreviationGuidlines}{this page}}. 

For details of the naming conventions, see \mbox{\hyperlink{index_ParaMonteNamingConventions}{this page}}. 

This software is distributed under the MIT-\/license. If you use any parts or concepts originated from this library, please acknowledge the usage by citing the \href{https://www.cdslab.org/paramonte/notes/overview/preface/\#how-to-acknowledge-the-use-of-the-paramonte-library-in-your-work}{\texttt{ {\bfseries{publications of the Para\+Monte library}}}}.~\newline

\end{DoxyRemark}
\begin{DoxyAuthor}{Author}
Amir Shahmoradi, September 1, 2017, 12\+:00 AM, ICES, The University of Texas at Austin 
\end{DoxyAuthor}


Definition at line \mbox{\hyperlink{ArrayComparison__mod_8f90_source_l00136}{136}} of file \mbox{\hyperlink{ArrayComparison__mod_8f90_source}{Array\+Comparison\+\_\+mod.\+f90}}.



The documentation for this interface was generated from the following file\+:\begin{DoxyCompactItemize}
\item 
/home/amir/git/paramonte/src/kernel/\+\_\+\+\_\+\+\_\+backup\+\_\+\+\_\+\+\_\+/\mbox{\hyperlink{ArrayComparison__mod_8f90}{Array\+Comparison\+\_\+mod.\+f90}}\end{DoxyCompactItemize}
