\hypertarget{namespaceArrayInsert__mod}{}\doxysection{Array\+Insert\+\_\+mod Module Reference}
\label{namespaceArrayInsert__mod}\index{ArrayInsert\_mod@{ArrayInsert\_mod}}


This module contains procedures for removing a insertion from arrays of various types at the specified instances of occurrence of insertion.  


\doxysubsection*{Data Types}
\begin{DoxyCompactItemize}
\item 
interface \mbox{\hyperlink{interfaceArrayInsert__mod_1_1insert}{insert}}
\begin{DoxyCompactList}\small\item\em Generate and return a new array containing the original array within which the input {\ttfamily Insertion} has been inserted at the specified indices {\ttfamily Index} of the original array. \end{DoxyCompactList}\end{DoxyCompactItemize}
\doxysubsection*{Variables}
\begin{DoxyCompactItemize}
\item 
character($\ast$), parameter \mbox{\hyperlink{namespaceArrayInsert__mod_a72123d45433ecba5e096d15388f79802}{MODULE\+\_\+\+NAME}} = \char`\"{}@Array\+Insert\+\_\+mod\char`\"{}
\end{DoxyCompactItemize}


\doxysubsection{Detailed Description}
This module contains procedures for removing a insertion from arrays of various types at the specified instances of occurrence of insertion. 

\begin{DoxyRefDesc}{Benchmarks}
\item[\mbox{\hyperlink{benchmarks__benchmarks000001}{Benchmarks}}]\end{DoxyRefDesc}


\label{namespaceArrayInsert__mod_benchmark-scalarInsertion_vs_vectorInsertion}%
\Hypertarget{namespaceArrayInsert__mod_benchmark-scalarInsertion_vs_vectorInsertion}%
{\bfseries{Benchmark \+:: The runtime performance of \mbox{\hyperlink{interfaceArrayInsert__mod_1_1insert}{insert}} for scalar vs. vector input {\ttfamily Insertion} argument.}} \href{\#benchmark-scalarInsertion_vs_vectorInsertion}{\texttt{ ⛓}} \begin{DoxyParagraph}{}

\begin{DoxyCodeInclude}{0}

\end{DoxyCodeInclude}
 ~\newline
 \label{namespaceArrayInsert__mod_compileb-unix-gnu-scalarInsertion_vs_vectorInsertion}%
\Hypertarget{namespaceArrayInsert__mod_compileb-unix-gnu-scalarInsertion_vs_vectorInsertion}%
{\bfseries{Example Unix compile command via GNU {\ttfamily gfortran} compiler}} \href{\#compileb-unix-gnu-scalarInsertion_vs_vectorInsertion}{\texttt{ ⛓}} 
\begin{DoxyCodeInclude}{0}
\DoxyCodeLine{\Hypertarget{namespaceArrayInsert__mod_l00001}00001 \#!/bin/bash}
\DoxyCodeLine{\Hypertarget{namespaceArrayInsert__mod_l00002}00002 gfortran -\/O3 -\/ffree-\/line-\/length-\/none -\/Wl,-\/rpath,../../../../lib -\/I../../../../include main.f90 ../../../../lib/libparamonte\_fortran\_*\_gnu\_*.so -\/o main.exe}
\DoxyCodeLine{\Hypertarget{namespaceArrayInsert__mod_l00003}00003 ./main.exe}

\end{DoxyCodeInclude}
 ~\newline
 \label{namespaceArrayInsert__mod_compileb-unix-intel-scalarInsertion_vs_vectorInsertion}%
\Hypertarget{namespaceArrayInsert__mod_compileb-unix-intel-scalarInsertion_vs_vectorInsertion}%
{\bfseries{Example Unix compile command via Intel {\ttfamily ifort} compiler}} \href{\#compileb-unix-intel-scalarInsertion_vs_vectorInsertion}{\texttt{ ⛓}} 
\begin{DoxyCodeInclude}{0}
\DoxyCodeLine{\Hypertarget{namespaceArrayInsert__mod_l00001}00001 \#!/bin/bash}
\DoxyCodeLine{\Hypertarget{namespaceArrayInsert__mod_l00002}00002 ifort -\/standard-\/semantics -\/O3 -\/Wl,-\/rpath,../../../../lib -\/I../../../../include main.f90 ../../../../lib/libparamonte\_fortran\_*\_intel\_*.so -\/o main.exe}
\DoxyCodeLine{\Hypertarget{namespaceArrayInsert__mod_l00003}00003 ./main.exe}

\end{DoxyCodeInclude}
 ~\newline
 \label{namespaceArrayInsert__mod_postprocb-scalarInsertion_vs_vectorInsertion}%
\Hypertarget{namespaceArrayInsert__mod_postprocb-scalarInsertion_vs_vectorInsertion}%
{\bfseries{Postprocessing of the output}} \href{\#postprocb-scalarInsertion_vs_vectorInsertion}{\texttt{ ⛓}} 
\begin{DoxyCodeInclude}{0}

\end{DoxyCodeInclude}
 ~\newline
 \label{namespaceArrayInsert__mod_visb-scalarInsertion_vs_vectorInsertion}%
\Hypertarget{namespaceArrayInsert__mod_visb-scalarInsertion_vs_vectorInsertion}%
{\bfseries{Visualization of the benchmark output}} \href{\#visb-scalarInsertion_vs_vectorInsertion}{\texttt{ ⛓}} \DoxyHorRuler{0}
   ~\newline
 \label{namespaceArrayInsert__mod_moralb-scalarInsertion_vs_vectorInsertion}%
\Hypertarget{namespaceArrayInsert__mod_moralb-scalarInsertion_vs_vectorInsertion}%
{\bfseries{Benchmark moral}} \href{\#moralb-scalarInsertion_vs_vectorInsertion}{\texttt{ ⛓}} \DoxyHorRuler{0}

\begin{DoxyEnumerate}
\item The procedures under the generic interface \mbox{\hyperlink{interfaceArrayInsert__mod_1_1insert}{insert}} take both scalar and vector {\ttfamily Insertion} arguments. As evidenced by the above benchmark, when the input {\ttfamily Insertion} is vector of length {\ttfamily 1}, it is much faster, {\bfseries{up to 4X}}, to pass {\ttfamily Insertion} as a scalar instead of a whole array of length {\ttfamily 1}. Note that this benchmark is not relevant to removing substrings from Fortran strings.
\end{DoxyEnumerate}
\end{DoxyParagraph}


\label{namespaceArrayInsert__mod_benchmark-genRemoved_vs_insert}%
\Hypertarget{namespaceArrayInsert__mod_benchmark-genRemoved_vs_insert}%
{\bfseries{Benchmark \+:: The runtime performance of gen\+Removed vs. \mbox{\hyperlink{interfaceArrayInsert__mod_1_1insert}{insert}}}} \href{\#benchmark-genRemoved_vs_insert}{\texttt{ ⛓}} \begin{DoxyParagraph}{}

\begin{DoxyCodeInclude}{0}

\end{DoxyCodeInclude}
 ~\newline
 \label{namespaceArrayInsert__mod_compileb-unix-gnu-genRemoved_vs_insert}%
\Hypertarget{namespaceArrayInsert__mod_compileb-unix-gnu-genRemoved_vs_insert}%
{\bfseries{Example Unix compile command via GNU {\ttfamily gfortran} compiler}} \href{\#compileb-unix-gnu-genRemoved_vs_insert}{\texttt{ ⛓}} 
\begin{DoxyCodeInclude}{0}
\DoxyCodeLine{\Hypertarget{namespaceArrayInsert__mod_l00001}00001 \#!/bin/bash}
\DoxyCodeLine{\Hypertarget{namespaceArrayInsert__mod_l00002}00002 gfortran -\/O3 -\/ffree-\/line-\/length-\/none -\/Wl,-\/rpath,../../../../lib -\/I../../../../include main.f90 ../../../../lib/libparamonte\_fortran\_*\_gnu\_*.so -\/o main.exe}
\DoxyCodeLine{\Hypertarget{namespaceArrayInsert__mod_l00003}00003 ./main.exe}

\end{DoxyCodeInclude}
 ~\newline
 \label{namespaceArrayInsert__mod_compileb-unix-intel-genRemoved_vs_insert}%
\Hypertarget{namespaceArrayInsert__mod_compileb-unix-intel-genRemoved_vs_insert}%
{\bfseries{Example Unix compile command via Intel {\ttfamily ifort} compiler}} \href{\#compileb-unix-intel-genRemoved_vs_insert}{\texttt{ ⛓}} 
\begin{DoxyCodeInclude}{0}
\DoxyCodeLine{\Hypertarget{namespaceArrayInsert__mod_l00001}00001 \#!/bin/bash}
\DoxyCodeLine{\Hypertarget{namespaceArrayInsert__mod_l00002}00002 ifort -\/standard-\/semantics -\/O3 -\/Wl,-\/rpath,../../../../lib -\/I../../../../include main.f90 ../../../../lib/libparamonte\_fortran\_*\_intel\_*.so -\/o main.exe}
\DoxyCodeLine{\Hypertarget{namespaceArrayInsert__mod_l00003}00003 ./main.exe}

\end{DoxyCodeInclude}
 ~\newline
 \label{namespaceArrayInsert__mod_postprocb-genRemoved_vs_insert}%
\Hypertarget{namespaceArrayInsert__mod_postprocb-genRemoved_vs_insert}%
{\bfseries{Postprocessing of the output}} \href{\#postprocb-genRemoved_vs_insert}{\texttt{ ⛓}} 
\begin{DoxyCodeInclude}{0}

\end{DoxyCodeInclude}
 ~\newline
 \label{namespaceArrayInsert__mod_visb-genRemoved_vs_insert}%
\Hypertarget{namespaceArrayInsert__mod_visb-genRemoved_vs_insert}%
{\bfseries{Visualization of the benchmark output}} \href{\#visb-genRemoved_vs_insert}{\texttt{ ⛓}} \DoxyHorRuler{0}
   ~\newline
 \label{namespaceArrayInsert__mod_moralb-genRemoved_vs_insert}%
\Hypertarget{namespaceArrayInsert__mod_moralb-genRemoved_vs_insert}%
{\bfseries{Benchmark moral}} \href{\#moralb-genRemoved_vs_insert}{\texttt{ ⛓}} \DoxyHorRuler{0}

\begin{DoxyEnumerate}
\item The procedures under the generic interface gen\+Removed are functions while the procedures under the generic interface \mbox{\hyperlink{interfaceArrayInsert__mod_1_1insert}{insert}} are subroutines. From the benchmark results, it appears that the functional interface performs slightly less efficiently than the subroutine interface, despite the two algorithms having the same implementation.
\item Note that this benchmark does not even include the cost of repeated reallcations, that is, the allocation of {\ttfamily Removed} happen only once in all tests.
\item Note that this benchmark considers the worst-\/case scenario where all insertions of the input {\ttfamily Array} match the input {\ttfamily Insertion} and must be therefore, inserted.
\end{DoxyEnumerate}
\end{DoxyParagraph}
\begin{DoxyRefDesc}{Test}
\item[\mbox{\hyperlink{test__test000002}{Test}}]\mbox{\hyperlink{namespaceTest__ArrayInsert__mod}{Test\+\_\+\+Array\+Insert\+\_\+mod}}\end{DoxyRefDesc}


\begin{DoxyRemark}{Remarks}
For details of naming abbreviations, see \mbox{\hyperlink{index_ParaMonteAbbreviationGuidlines}{this page}}. 

For details of the naming conventions, see \mbox{\hyperlink{index_ParaMonteNamingConventions}{this page}}. 

This software is distributed under the MIT-\/license. If you use any parts or concepts originated from this library, please acknowledge the usage by citing the \href{https://www.cdslab.org/paramonte/notes/overview/preface/\#how-to-acknowledge-the-use-of-the-paramonte-library-in-your-work}{\texttt{ {\bfseries{publications of the Para\+Monte library}}}}.~\newline

\end{DoxyRemark}
\begin{DoxyAuthor}{Author}
Amir Shahmoradi, Wednesday 12\+:20 AM, October 13, 2021, Dallas, TX 
\end{DoxyAuthor}


\doxysubsection{Variable Documentation}
\mbox{\Hypertarget{namespaceArrayInsert__mod_a72123d45433ecba5e096d15388f79802}\label{namespaceArrayInsert__mod_a72123d45433ecba5e096d15388f79802}} 
\index{ArrayInsert\_mod@{ArrayInsert\_mod}!MODULE\_NAME@{MODULE\_NAME}}
\index{MODULE\_NAME@{MODULE\_NAME}!ArrayInsert\_mod@{ArrayInsert\_mod}}
\doxysubsubsection{\texorpdfstring{MODULE\_NAME}{MODULE\_NAME}}
{\footnotesize\ttfamily character($\ast$), parameter Array\+Insert\+\_\+mod\+::\+MODULE\+\_\+\+NAME = \char`\"{}@Array\+Insert\+\_\+mod\char`\"{}}



Definition at line \mbox{\hyperlink{ArrayInsert__mod_8f90_source_l00090}{90}} of file \mbox{\hyperlink{ArrayInsert__mod_8f90_source}{Array\+Insert\+\_\+mod.\+f90}}.

