\hypertarget{namespaceKmeans__mod}{}\doxysection{Kmeans\+\_\+mod Module Reference}
\label{namespaceKmeans__mod}\index{Kmeans\_mod@{Kmeans\_mod}}


This module contains procedures and routines for the Kmeans the statistical classification and clustering methods.  


\doxysubsection*{Data Types}
\begin{DoxyCompactItemize}
\item 
interface \mbox{\hyperlink{structKmeans__mod_1_1Kmeans__type}{Kmeans\+\_\+type}}
\begin{DoxyCompactList}\small\item\em The {\ttfamily \mbox{\hyperlink{structKmeans__mod_1_1Kmeans__type}{Kmeans\+\_\+type}}} class. The inclusion of the component {\ttfamily Normed\+Point} adds $\sim$50\% to the computational cost of performing Kmeans. In this latest implementation, avoiding {\ttfamily Normed\+Point} as a component leads to 15-\/50\% performance improvement. The moral is, simple repeating of addition operation is much significantly cheaper than storing the operation results for later usage. In the following declaration descriptions,. \end{DoxyCompactList}\item 
type \mbox{\hyperlink{structKmeans__mod_1_1Prop__type}{Prop\+\_\+type}}
\begin{DoxyCompactList}\small\item\em The {\ttfamily \mbox{\hyperlink{structKmeans__mod_1_1Prop__type}{Prop\+\_\+type}}} class, containing the properties of Kmeans clusters. \end{DoxyCompactList}\end{DoxyCompactItemize}
\doxysubsection*{Functions/\+Subroutines}
\begin{DoxyCompactItemize}
\item 
pure type(\mbox{\hyperlink{structKmeans__mod_1_1Kmeans__type}{Kmeans\+\_\+type}}) function \mbox{\hyperlink{namespaceKmeans__mod_a5fb9bb4b4505ce4fce10ba73e509af2f}{allocate\+Kmeans}} (nd, np, nc)
\item 
pure subroutine \mbox{\hyperlink{namespaceKmeans__mod_ad8b3b0fdff3dd016e9b42d5ae6d6ed59}{allocate\+Kmeans\+Prop}} (Prop, nd, np, nc)
\item 
type(\mbox{\hyperlink{structKmeans__mod_1_1Kmeans__type}{Kmeans\+\_\+type}}) function \mbox{\hyperlink{namespaceKmeans__mod_a326680f1f273d7651781eed4879d4d4f}{get\+Kmeans}} (nd, np, nc, nt, Point, Init\+Center, rel\+Tol, niter\+Max, nfail\+Max, min\+Size)
\begin{DoxyCompactList}\small\item\em Perform the Kmeans clustering for {\ttfamily nt} tries on the input data set represented by the array {\ttfamily Point(nd, np)} and return the clustering that yields the least potential. \end{DoxyCompactList}\item 
subroutine \mbox{\hyperlink{namespaceKmeans__mod_abd3a6d85bd62c09c556b239a510c88f8}{run\+Kmeans}} (nd, np, nc, nfail\+Max, niter\+Max, min\+Size, rel\+Tol, Point, Size, niter, nfail, Center, potential, Membership, Min\+Distance\+Sq, Err, Init\+Center)
\begin{DoxyCompactList}\small\item\em Perform the Kmeans clustering on the input data set represented by the array {\ttfamily Point(nd, np)}. \end{DoxyCompactList}\item 
subroutine \mbox{\hyperlink{namespaceKmeans__mod_a825a144e084e48f30e8fdd462d8ffc3a}{get\+Prop}} (Kmeans, nd, np, Point, Index, inclusion\+Fraction, point\+Log\+Vol\+Normed)
\begin{DoxyCompactList}\small\item\em This is a method of class \mbox{\hyperlink{structKmeans__mod_1_1Kmeans__type}{Kmeans\+\_\+type}}. Compute the following properties (components) of the input object of class \mbox{\hyperlink{structKmeans__mod_1_1Kmeans__type}{Kmeans\+\_\+type}}\+: \end{DoxyCompactList}\item 
subroutine \mbox{\hyperlink{namespaceKmeans__mod_ac4b9beeaf1a19b79cfd5aacb8915fb02}{run\+KPP}} (nc, nd, np, Point, Sum\+Point, Membership, Size, potential)
\begin{DoxyCompactList}\small\item\em Find nc initial cluster centers for the Kmeans algorithm, using Kmeans++ recipe. \end{DoxyCompactList}\item 
subroutine \mbox{\hyperlink{namespaceKmeans__mod_a7e385bbc9ba8d03f353899bacaa05911}{write\+Kmeans}} (Kmeans, Point, nd, np, file\+Unit)
\end{DoxyCompactItemize}
\doxysubsection*{Variables}
\begin{DoxyCompactItemize}
\item 
character($\ast$), parameter \mbox{\hyperlink{namespaceKmeans__mod_a8e45620d83ae161f59cf82556da7dc9e}{MODULE\+\_\+\+NAME}} = \char`\"{}@Kmeans\+\_\+mod\char`\"{}
\end{DoxyCompactItemize}


\doxysubsection{Detailed Description}
This module contains procedures and routines for the Kmeans the statistical classification and clustering methods. 

\begin{DoxyAuthor}{Author}
Amir Shahmoradi 
\end{DoxyAuthor}


\doxysubsection{Function/\+Subroutine Documentation}
\mbox{\Hypertarget{namespaceKmeans__mod_a5fb9bb4b4505ce4fce10ba73e509af2f}\label{namespaceKmeans__mod_a5fb9bb4b4505ce4fce10ba73e509af2f}} 
\index{Kmeans\_mod@{Kmeans\_mod}!allocateKmeans@{allocateKmeans}}
\index{allocateKmeans@{allocateKmeans}!Kmeans\_mod@{Kmeans\_mod}}
\doxysubsubsection{\texorpdfstring{allocateKmeans()}{allocateKmeans()}}
{\footnotesize\ttfamily pure type(\mbox{\hyperlink{structKmeans__mod_1_1Kmeans__type}{Kmeans\+\_\+type}}) function Kmeans\+\_\+mod\+::allocate\+Kmeans (\begin{DoxyParamCaption}\item[{integer, intent(in)}]{nd,  }\item[{integer, intent(in)}]{np,  }\item[{integer, intent(in)}]{nc }\end{DoxyParamCaption})}



Definition at line \mbox{\hyperlink{Kmeans__mod_8f90_source_l00114}{114}} of file \mbox{\hyperlink{Kmeans__mod_8f90_source}{Kmeans\+\_\+mod.\+f90}}.

\mbox{\Hypertarget{namespaceKmeans__mod_ad8b3b0fdff3dd016e9b42d5ae6d6ed59}\label{namespaceKmeans__mod_ad8b3b0fdff3dd016e9b42d5ae6d6ed59}} 
\index{Kmeans\_mod@{Kmeans\_mod}!allocateKmeansProp@{allocateKmeansProp}}
\index{allocateKmeansProp@{allocateKmeansProp}!Kmeans\_mod@{Kmeans\_mod}}
\doxysubsubsection{\texorpdfstring{allocateKmeansProp()}{allocateKmeansProp()}}
{\footnotesize\ttfamily pure subroutine Kmeans\+\_\+mod\+::allocate\+Kmeans\+Prop (\begin{DoxyParamCaption}\item[{class(\mbox{\hyperlink{structKmeans__mod_1_1Prop__type}{Prop\+\_\+type}})}]{Prop,  }\item[{integer, intent(in)}]{nd,  }\item[{integer, intent(in)}]{np,  }\item[{integer, intent(in)}]{nc }\end{DoxyParamCaption})}



Definition at line \mbox{\hyperlink{Kmeans__mod_8f90_source_l00128}{128}} of file \mbox{\hyperlink{Kmeans__mod_8f90_source}{Kmeans\+\_\+mod.\+f90}}.

\mbox{\Hypertarget{namespaceKmeans__mod_a326680f1f273d7651781eed4879d4d4f}\label{namespaceKmeans__mod_a326680f1f273d7651781eed4879d4d4f}} 
\index{Kmeans\_mod@{Kmeans\_mod}!getKmeans@{getKmeans}}
\index{getKmeans@{getKmeans}!Kmeans\_mod@{Kmeans\_mod}}
\doxysubsubsection{\texorpdfstring{getKmeans()}{getKmeans()}}
{\footnotesize\ttfamily type(\mbox{\hyperlink{structKmeans__mod_1_1Kmeans__type}{Kmeans\+\_\+type}}) function Kmeans\+\_\+mod\+::get\+Kmeans (\begin{DoxyParamCaption}\item[{integer, intent(in)}]{nd,  }\item[{integer, intent(in)}]{np,  }\item[{integer, intent(in)}]{nc,  }\item[{integer, intent(in)}]{nt,  }\item[{real(RK)}]{Point,  }\item[{real(RK)}]{Init\+Center,  }\item[{real(RK)}]{rel\+Tol,  }\item[{integer}]{niter\+Max,  }\item[{integer}]{nfail\+Max,  }\item[{integer}]{min\+Size }\end{DoxyParamCaption})}



Perform the Kmeans clustering for {\ttfamily nt} tries on the input data set represented by the array {\ttfamily Point(nd, np)} and return the clustering that yields the least potential. 


\begin{DoxyParams}[1]{Parameters}
\mbox{\texttt{ in}}  & {\em nd} & \+: The number of dimensions (attributes) in the input {\ttfamily Point}. \\
\hline
\mbox{\texttt{ in}}  & {\em np} & \+: The number of observations in the input {\ttfamily Point}. \\
\hline
\mbox{\texttt{ in}}  & {\em nc} & \+: The number of clusters to identify. \\
\hline
\mbox{\texttt{ in}}  & {\em nt} & \+: The number of independent instances of Kmeans to run. \\
\hline
\mbox{\texttt{ in}}  & {\em Point} & \+: An array of size {\ttfamily (nd,np)} containing the input dataset to cluster. \\
\hline
\mbox{\texttt{ in}}  & {\em Init\+Center} & \+: An array of size {\ttfamily (nd,nc)} containing the best-\/guess cluster centers ({\bfseries{optional}}, default = set via Kpp). \\
\hline
\mbox{\texttt{ in}}  & {\em niter\+Max} & \+: The maximum allowed number of iterations in the algorithm of Lloyd ({\bfseries{optional}}, default = {\ttfamily 300}). \\
\hline
\mbox{\texttt{ in}}  & {\em nfail\+Max} & \+: The maximum allowed number of failures in the algorithm of Lloyd ({\bfseries{optional}}, default = {\ttfamily 2}). \\
\hline
\mbox{\texttt{ in}}  & {\em min\+Size} & \+: The minimum allowed size of a cluster ({\bfseries{optional}}, default = {\ttfamily 0}). \\
\hline
\mbox{\texttt{ in}}  & {\em rel\+Tol} & \+: See the description of the \mbox{\hyperlink{namespaceKmeans__mod_abd3a6d85bd62c09c556b239a510c88f8}{run\+Kmeans()}}.\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
{\ttfamily Kmeans} \+: An object of type \mbox{\hyperlink{structKmeans__mod_1_1Kmeans__type}{Kmeans\+\_\+type}} containing the properties of the identified clusters. The {\ttfamily Errstat} component of the output {\ttfamily Kmeans} will be set to {\ttfamily 1} if the number of iterations reaches the input {\ttfamily niter\+Max} or its default value before convergence occurs. The {\ttfamily Errstat} component of the output {\ttfamily Kmeans} will be set to {\ttfamily 2} if more than {\ttfamily nfail\+Max} clustering tries result in clusters with zero members. In both cases in the above, {\ttfamily Erroccurred = .true.} upon exiting the procedure.
\end{DoxyReturn}
\begin{DoxyRemark}{Remarks}
An {\ttfamily Errstat = 1} indicates lack of convergence upon exit from the Kmeans algorithm.

An {\ttfamily Errstat = 2} indicates lack of convergence upon exit from the Kmeans algorithm, due to too many clustering attempts resulting in clusters with size \texorpdfstring{$<$}{<} {\ttfamily min\+Size}.
\end{DoxyRemark}
\begin{DoxyWarning}{Warning}
The input value for {\ttfamily nt} must be at least 1, otherwise it will lead to a runtime error or at best, the output will be undefined.

The input value for {\ttfamily niter\+Max} must be larger than 0 since at least one iteration will be performed by the procedure.

This algorithm does not check for the consistency of the input values for {\ttfamily nc}, {\ttfamily nd}, and {\ttfamily np}. It is currently the responsibility of the user to ensure that these input values are logical and sensible.
\end{DoxyWarning}
\begin{DoxyAuthor}{Author}

\end{DoxyAuthor}


Definition at line \mbox{\hyperlink{Kmeans__mod_8f90_source_l00187}{187}} of file \mbox{\hyperlink{Kmeans__mod_8f90_source}{Kmeans\+\_\+mod.\+f90}}.

\mbox{\Hypertarget{namespaceKmeans__mod_a825a144e084e48f30e8fdd462d8ffc3a}\label{namespaceKmeans__mod_a825a144e084e48f30e8fdd462d8ffc3a}} 
\index{Kmeans\_mod@{Kmeans\_mod}!getProp@{getProp}}
\index{getProp@{getProp}!Kmeans\_mod@{Kmeans\_mod}}
\doxysubsubsection{\texorpdfstring{getProp()}{getProp()}}
{\footnotesize\ttfamily subroutine Kmeans\+\_\+mod\+::get\+Prop (\begin{DoxyParamCaption}\item[{class(\mbox{\hyperlink{structKmeans__mod_1_1Kmeans__type}{Kmeans\+\_\+type}})}]{Kmeans,  }\item[{integer(IK), intent(in)}]{nd,  }\item[{integer(IK), intent(in)}]{np,  }\item[{real(RK)}]{Point,  }\item[{integer(IK)}]{Index,  }\item[{real(RK)}]{inclusion\+Fraction,  }\item[{real(RK)}]{point\+Log\+Vol\+Normed }\end{DoxyParamCaption})}



This is a method of class \mbox{\hyperlink{structKmeans__mod_1_1Kmeans__type}{Kmeans\+\_\+type}}. Compute the following properties (components) of the input object of class \mbox{\hyperlink{structKmeans__mod_1_1Kmeans__type}{Kmeans\+\_\+type}}\+: 


\begin{DoxyItemize}
\item {\ttfamily Cho\+Low\+Cov\+Upp(1\+:nd,1\+:nd,1\+:nc)} \+: The covariance matrix upper triangle and Cholesky factor lower triangle,
\item {\ttfamily Inv\+Cov\+Mat(1\+:nd,1\+:nd,1\+:nc)} \+: The full inverse covariance matrix,
\item {\ttfamily Effective\+Size(1\+:nc)} \+: The effective sizes of the ellipsoidal bounded regions of the clusters.
\item {\ttfamily Scale\+Factor\+Sq(1\+:nc)} \+: The factor by which the covariance matrix elements must be multiplied to convert the matrix to a bounding ellipsoid of the cluster members.
\item {\ttfamily Mahal\+Sq(1\+:np,1\+:nc)} \+: The Mahalanobis distances squared of all points from all cluster centers,
\item {\ttfamily Cho\+Dia(1\+:nd,1\+:nc)} \+: The diagonal elements of the Cholesky lower triangle,
\item {\ttfamily Cum\+Sum\+Size(0\+:nc)} \+: The cumulative sum of {\ttfamily KmeansSize(1\+:nc)} with {\ttfamily Cum\+Sum\+Size(0) = 0},
\item {\ttfamily Log\+Vol\+Normed(1\+:nc)} \+: The vector of natural-\/log volumes of all clusters normalized by the volume of unit nd-\/ball,
\end{DoxyItemize}


\begin{DoxyParams}[1]{Parameters}
\mbox{\texttt{ in}}  & {\em Kmeans} & \+: An object of class \mbox{\hyperlink{structKmeans__mod_1_1Kmeans__type}{Kmeans\+\_\+type}}. \\
\hline
\mbox{\texttt{ in}}  & {\em nd} & \+: See the description of the \mbox{\hyperlink{namespaceKmeans__mod_abd3a6d85bd62c09c556b239a510c88f8}{run\+Kmeans}}. \\
\hline
\mbox{\texttt{ in}}  & {\em np} & \+: See the description of the \mbox{\hyperlink{namespaceKmeans__mod_abd3a6d85bd62c09c556b239a510c88f8}{run\+Kmeans}}. \\
\hline
\mbox{\texttt{ in,out}}  & {\em Point} & \+: The Array of size {\ttfamily (nd,np)} representing the original points used in Kmeans clustering. \\
\hline
\mbox{\texttt{ in,out}}  & {\em Index} & \+: A vector of size {\ttfamily np} such that the output {\ttfamily Point(\+:,\+Index(ip),\+:)} points to the input {\ttfamily Point(\+:,ip)} ({\bfseries{optional}}, if not provided, it will be stored in {\ttfamily PropIndex} component of the input {\ttfamily Kmeans} object). \\
\hline
\mbox{\texttt{ in}}  & {\em inclusion\+Fraction} & \+: The fraction of points inside the bounding region of each cluster to be considered in computing the effective sizes of the bounded regions of each cluster ({\bfseries{optional}}, default = {\ttfamily 0.}). \\
\hline
\mbox{\texttt{ in}}  & {\em point\+Log\+Vol\+Normed} & \+: The logarithm of the volume of a single point, to be used for assigning the properties of singular clusters. ({\bfseries{optional}}, if not provided or if set to {\ttfamily NEGINF\+\_\+\+RK}, the volume will be estimated via the other non-\/singular clusters).\\
\hline
\end{DoxyParams}
\begin{DoxyWarning}{Warning}
If any cluster has less than {\ttfamily nd + 1} members, its properties will not be computed, unless {\ttfamily point\+Log\+Vol} is provided as input. When {\ttfamily point\+Log\+Vol} is provided, the properties of any non-\/zero-\/size cluster will be computed as hyper-\/sphere whose volume is the volume of a single point times the number of cluster members. Obviously, the properties of cluster of zero size will not be set.

If {\ttfamily inclusion\+Fraction = 0.}, then all clusters are effective assumed to be non-\/overlapping. This issue becomes particularly relevant when computing the effective sum of volumes and average density across all clusters.

Upon entry to this method, the {\ttfamily Center}, {\ttfamily Size}, and {\ttfamily Membership} components of the Kmeans object must have been already properly set up by its class constructor or a call to {\ttfamily \mbox{\hyperlink{namespaceKmeans__mod_a326680f1f273d7651781eed4879d4d4f}{get\+Kmeans()}}}.

On output, the arrays {\ttfamily Point} and {\ttfamily Index} will be rearranged on exit from the procedure such that the members of the same clusters appear next to each other contiguously in the array. Consequently, the output array component {\ttfamily Index(1\+:np)} will be populated such that the input {\ttfamily Point(1\+:nd,\+Index(ip))} is saved at the output {\ttfamily Point(1\+:nd,ip)}.

If the Cholesky factorization in the procedure fails, the control is returned with {\ttfamily KmeansErroccurred = .true.}.

If {\ttfamily point\+Log\+Vol\+Normed} is provided on input, it will be solely used to define the properties of singular clusters. Consequently, the densities of singular clusters will be the same while the densities of non-\/singular clusters will be different from each other and from those of singular clusters. 
\end{DoxyWarning}


Definition at line \mbox{\hyperlink{Kmeans__mod_8f90_source_l00676}{676}} of file \mbox{\hyperlink{Kmeans__mod_8f90_source}{Kmeans\+\_\+mod.\+f90}}.

\mbox{\Hypertarget{namespaceKmeans__mod_abd3a6d85bd62c09c556b239a510c88f8}\label{namespaceKmeans__mod_abd3a6d85bd62c09c556b239a510c88f8}} 
\index{Kmeans\_mod@{Kmeans\_mod}!runKmeans@{runKmeans}}
\index{runKmeans@{runKmeans}!Kmeans\_mod@{Kmeans\_mod}}
\doxysubsubsection{\texorpdfstring{runKmeans()}{runKmeans()}}
{\footnotesize\ttfamily subroutine Kmeans\+\_\+mod\+::run\+Kmeans (\begin{DoxyParamCaption}\item[{integer, intent(in)}]{nd,  }\item[{integer, intent(in)}]{np,  }\item[{integer, intent(in)}]{nc,  }\item[{integer}]{nfail\+Max,  }\item[{integer}]{niter\+Max,  }\item[{integer}]{min\+Size,  }\item[{real(RK)}]{rel\+Tol,  }\item[{real(RK)}]{Point,  }\item[{integer}]{Size,  }\item[{integer, intent(out)}]{niter,  }\item[{integer, intent(out)}]{nfail,  }\item[{real(RK)}]{Center,  }\item[{real(RK), intent(out)}]{potential,  }\item[{integer}]{Membership,  }\item[{real(RK)}]{Min\+Distance\+Sq,  }\item[{type(\mbox{\hyperlink{structErr__mod_1_1Err__type}{Err\+\_\+type}})}]{Err,  }\item[{real(RK)}]{Init\+Center }\end{DoxyParamCaption})}



Perform the Kmeans clustering on the input data set represented by the array {\ttfamily Point(nd, np)}. 


\begin{DoxyParams}[1]{Parameters}
\mbox{\texttt{ in}}  & {\em nd} & \+: The number of dimensions (features) of the input data array {\ttfamily Point}. \\
\hline
\mbox{\texttt{ in}}  & {\em np} & \+: The number of observations in the input data array {\ttfamily Point}. \\
\hline
\mbox{\texttt{ in}}  & {\em nc} & \+: The number of clusters to be found via the Kmeans algorithm. \\
\hline
\mbox{\texttt{ in}}  & {\em nfail\+Max} & \+: A non-\/negative integer, representing the maximum allowed number of min\+Size-\/cluster iterations beyond which it a lack of converge is assumed. \\
\hline
\mbox{\texttt{ in}}  & {\em niter\+Max} & \+: A non-\/negative integer, representing the maximum allowed number of iterations beyond which it a lack of converge is assumed. \\
\hline
\mbox{\texttt{ in}}  & {\em min\+Size} & \+: A non-\/negative integer, representing the minimum allowed number of points in each cluster. \\
\hline
\mbox{\texttt{ in}}  & {\em rel\+Tol} & \+: If the {\bfseries{relative}} difference between two subsequent potentials is below {\ttfamily rel\+Tol}, convergence is assumed. \\
\hline
\mbox{\texttt{ in}}  & {\em Point} & \+: The input array of size {\ttfamily (nd,np)} of the points to be clustered via the Kmeans algorithm. \\
\hline
\mbox{\texttt{ out}}  & {\em Size} & \+: A vector of size {\ttfamily nc} (the number of clusters) containing the sizes of the individual clusters identified. \\
\hline
\mbox{\texttt{ out}}  & {\em Center} & \+: An array of size {\ttfamily (nd,nc)} containing the centers of the individual clusters identified. \\
\hline
\mbox{\texttt{ out}}  & {\em Membership} & \+: A vector of size {\ttfamily np} each element of which represents the cluster ID to which the point belongs. \\
\hline
\mbox{\texttt{ out}}  & {\em Min\+Distance\+Sq} & \+: An array of size {\ttfamily (np)} containing the minimum distances of the points from the cluster centers. \\
\hline
\mbox{\texttt{ out}}  & {\em potential} & \+: The sum of the distances-\/squared of all points from their corresponding group centers. \\
\hline
\mbox{\texttt{ out}}  & {\em niter} & \+: The number of iterations to reach convergence. \\
\hline
\mbox{\texttt{ out}}  & {\em nfail} & \+: The number of iterations for which clusters with size smaller than {\ttfamily min\+Size} occurs. \\
\hline
\mbox{\texttt{ out}}  & {\em Err} & \+: An object of class \mbox{\hyperlink{structErr__mod_1_1Err__type}{Err\+\_\+type}} containing information about error occurrence. \\
\hline
\mbox{\texttt{ in}}  & {\em Init\+Center} & \+: An array of size {\ttfamily (nd,nc)} representing the initial centers of the clusters ({\bfseries{optional}}. If missing, Kmeans++ initializes {\ttfamily Init\+Center}).\\
\hline
\end{DoxyParams}
\begin{DoxyWarning}{Warning}
The input value for {\ttfamily niter\+Max} must be larger than 0 since at least one iteration will be performed by the procedure.

This algorithm does not check for the consistency of the input values for {\ttfamily nc}, {\ttfamily nd}, and {\ttfamily np}. It is currently the responsibility of the user to ensure that these input values are logical and sensible.
\end{DoxyWarning}
\begin{DoxyRemark}{Remarks}
If {\ttfamily niter\+Max = 0}, then no refinement of the centers based on the algorithm of Lloyd will be performed. In such a case, the cluster memberships will be determined based on the initial input {\ttfamily Init\+Center} or if not provided as input, base on the randomly-\/guessed {\ttfamily Center} using Kpp algorithm and the procedure will return before further refining the {\ttfamily Membership} and {\ttfamily Center}. It is currently the responsibility of the user to ensure that these input values are logical and sensible.
\end{DoxyRemark}
\begin{DoxyAuthor}{Author}

\end{DoxyAuthor}


Definition at line \mbox{\hyperlink{Kmeans__mod_8f90_source_l00385}{385}} of file \mbox{\hyperlink{Kmeans__mod_8f90_source}{Kmeans\+\_\+mod.\+f90}}.

\mbox{\Hypertarget{namespaceKmeans__mod_ac4b9beeaf1a19b79cfd5aacb8915fb02}\label{namespaceKmeans__mod_ac4b9beeaf1a19b79cfd5aacb8915fb02}} 
\index{Kmeans\_mod@{Kmeans\_mod}!runKPP@{runKPP}}
\index{runKPP@{runKPP}!Kmeans\_mod@{Kmeans\_mod}}
\doxysubsubsection{\texorpdfstring{runKPP()}{runKPP()}}
{\footnotesize\ttfamily subroutine Kmeans\+\_\+mod\+::run\+KPP (\begin{DoxyParamCaption}\item[{integer, intent(in)}]{nc,  }\item[{integer, intent(in)}]{nd,  }\item[{integer, intent(in)}]{np,  }\item[{real(RK)}]{Point,  }\item[{real(RK)}]{Sum\+Point,  }\item[{integer}]{Membership,  }\item[{integer}]{Size,  }\item[{real(RK), intent(out)}]{potential }\end{DoxyParamCaption})}



Find nc initial cluster centers for the Kmeans algorithm, using Kmeans++ recipe. 


\begin{DoxyParams}[1]{Parameters}
\mbox{\texttt{ in}}  & {\em nc} & \+: The number of clusters to be found via the Kmeans algorithm (must be \texorpdfstring{$>$}{>} 1, though it is not verified). \\
\hline
\mbox{\texttt{ in}}  & {\em nd} & \+: The number of dimensions (features) of the input data array {\ttfamily Point}. \\
\hline
\mbox{\texttt{ in}}  & {\em np} & \+: The number of observations in the input data array {\ttfamily Point}. \\
\hline
\mbox{\texttt{ in}}  & {\em Point} & \+: The input array of size {\ttfamily (nd,np)} of the points to be clustered via the Kmeans algorithm. \\
\hline
\mbox{\texttt{ out}}  & {\em Sum\+Point} & \+: An output array of size {\ttfamily (nd,nc)} containing the sum of the points in each cluster. When divided by the corresponding output cluster size, it will yield the final updated cluster centers. \\
\hline
\mbox{\texttt{ out}}  & {\em Membership} & \+: An output array of size {\ttfamily (np)} representing the IDs of the clusters to which individual points belong. \\
\hline
\mbox{\texttt{ out}}  & {\em Size} & \+: An output array of size {\ttfamily (nc)} representing the sizes of the identified clusters. \\
\hline
\mbox{\texttt{ out}}  & {\em potential} & \+: The sum of the minimum-\/distances-\/squared of all points from their corresponding group centers.\\
\hline
\end{DoxyParams}
\begin{DoxyWarning}{Warning}
There is no benefit in calling this routine for {\ttfamily nc = 1}. As such, calling this routine with {\ttfamily nc = 1} will lead to undefined behavior.
\end{DoxyWarning}
\begin{DoxyRefDesc}{Todo}
\item[\mbox{\hyperlink{todo__todo000006}{Todo}}]All {\ttfamily minloc} queries in this procedure can be replaced with more efficient bin search algorithms.\end{DoxyRefDesc}


\begin{DoxyRefDesc}{Todo}
\item[\mbox{\hyperlink{todo__todo000007}{Todo}}]The variable {\ttfamily Cum\+Sum\+Dist\+Sq} does not have to be defined as {\ttfamily real64}.\end{DoxyRefDesc}


\begin{DoxyAuthor}{Author}

\end{DoxyAuthor}


Definition at line \mbox{\hyperlink{Kmeans__mod_8f90_source_l00970}{970}} of file \mbox{\hyperlink{Kmeans__mod_8f90_source}{Kmeans\+\_\+mod.\+f90}}.

\mbox{\Hypertarget{namespaceKmeans__mod_a7e385bbc9ba8d03f353899bacaa05911}\label{namespaceKmeans__mod_a7e385bbc9ba8d03f353899bacaa05911}} 
\index{Kmeans\_mod@{Kmeans\_mod}!writeKmeans@{writeKmeans}}
\index{writeKmeans@{writeKmeans}!Kmeans\_mod@{Kmeans\_mod}}
\doxysubsubsection{\texorpdfstring{writeKmeans()}{writeKmeans()}}
{\footnotesize\ttfamily subroutine Kmeans\+\_\+mod\+::write\+Kmeans (\begin{DoxyParamCaption}\item[{type(\mbox{\hyperlink{structKmeans__mod_1_1Kmeans__type}{Kmeans\+\_\+type}})}]{Kmeans,  }\item[{real(RK)}]{Point,  }\item[{integer, intent(in)}]{nd,  }\item[{integer, intent(in)}]{np,  }\item[{integer}]{file\+Unit }\end{DoxyParamCaption})}



Definition at line \mbox{\hyperlink{Kmeans__mod_8f90_source_l01044}{1044}} of file \mbox{\hyperlink{Kmeans__mod_8f90_source}{Kmeans\+\_\+mod.\+f90}}.



\doxysubsection{Variable Documentation}
\mbox{\Hypertarget{namespaceKmeans__mod_a8e45620d83ae161f59cf82556da7dc9e}\label{namespaceKmeans__mod_a8e45620d83ae161f59cf82556da7dc9e}} 
\index{Kmeans\_mod@{Kmeans\_mod}!MODULE\_NAME@{MODULE\_NAME}}
\index{MODULE\_NAME@{MODULE\_NAME}!Kmeans\_mod@{Kmeans\_mod}}
\doxysubsubsection{\texorpdfstring{MODULE\_NAME}{MODULE\_NAME}}
{\footnotesize\ttfamily character($\ast$), parameter Kmeans\+\_\+mod\+::\+MODULE\+\_\+\+NAME = \char`\"{}@Kmeans\+\_\+mod\char`\"{}}



Definition at line \mbox{\hyperlink{Kmeans__mod_8f90_source_l00055}{55}} of file \mbox{\hyperlink{Kmeans__mod_8f90_source}{Kmeans\+\_\+mod.\+f90}}.

